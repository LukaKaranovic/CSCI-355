These are notes 3b on VIULearn.
# Full Adder
What are the expressions for sum (s<sub>i</sub>) and carry-out c<sub>i+1</sub> for a given input x<sub>i</sub>, y<sub>i</sub>, c<sub>i</sub> in a full adder?

- s<sub>i</sub> = (x<sub>i</sub> XOR y<sub>i</sub>) XOR c<sub>i</sub>
- c<sub>i+1</sub> = xiyi + xici + y<sub>i</sub>c<sub>i</sub>

We get this circuit:
![[fulladdercircuit.png]]

## Structural Specification
```Verilog
	module fulladd(Cin, x, y, s, Cout);
		input Cin, x, y;
		output s, Cout;
		wire z1, z2, z3;
		
		xor(s, x, y, Cin);
		
		and(z1, x, y);
		and(z2, x, Cin);
		and(z3, y, Cin);
		or(Cout, z1, z2, z3);
	endmodule
```

## Continuous Assignment
```Verilog
	module fulladd(Cin, x, y, s, Cout);
		input Cin, x, y;
		output s, Cout;
		
		assign s = x ^ y ^ Cin;
		assign Cout = (x & y) | (x & Cin) | (y & Cin);
		
	endmodule
```

## Ordered vs. Named Ports
There are two ways of specifying which signals get connected to which ports on a module when instantiating it.

Consider the `fulladd` module defined above.
- **Order Ports** -> signals are connected in the **same order** as in the module instantiation statement.
	- Ex. `fulladd U0 (0, a, b, sum, c);`
- **Named Ports** -> uses the **name** of the input/output in module instantiation.
	- Ex. `fulladd U0(.x(a), .y(b), .s(sum), .Cin(0), .Cout(c));`
	- Don't need to follow the order.

## Test Bench for Full Adder Simulation
```Verilog
	`timescale 1ns/1ns // scale/precision
	
	module fulladd_tb(); // testbench module
		reg c, a, b;
		wire s, ct;
		fulladd ut(.Cout(ct), .x(a), .Cin(c), .y(b), .s(s)); // module instantiation
		
		initial begin
			{c, a, b} = 3'd0; #20;
			{c, a, b} = 3'd1; #20;
			{c, a, b} = 3'd2; #20;
			{c, a, b} = 3'd3; #20;
			{c, a, b} = 3'd4; #20;
			{c, a, b} = 3'd5; #20;
			{c, a, b} = 3'd6; #20;
			{c, a, b} = 3'd7; #20;
		end
	endmodule
```
- Could instantiate module as `fulladd ut(c, a, b, s, ct);` instead.
- `initial` block represents a separate process (where statements execute sequentially within it)
	- Unlike `always` block, `initial` block executes only once
- `#20;` is to set delay of 20 units (ns in this case)
- `{}` is used to concatenate bits together
- Numbers can be given as **constants** in Verilog:
	- `<size_in_bits>'<radix_identifier><sig_digits>`
	- `3'd0` is a 3 bit decimal 0

# Ripple-Carry Adder
A ripple-carry adder is formed by "chaining" n full-adders.
![[ripplecarry2.png]]

```Verilog
	module adder4 (carryin, x3, x2, x1, x0, y3, y2, y1, y0, s3, s2, s1, s0, carryout);  
		input carryin, x3, x2, x1, x0, y3, y2, y1, y0;  
		output s3, s2, s1, s0, carryout;  
		fulladd stage0 (carryin, x0, y0, s0, c1);  
		fulladd stage1 (c1, x1, y1, s1, c2);  
		fulladd stage2 (c2, x2, y2, s2, c3);  
		fulladd stage3 (c3, x3, y3, s3, carryout);  
	endmodule
	
	module fulladd (Cin, x, y, s, Cout);  
		input Cin, x, y;  
		output s, Cout;  
		assign s = x ^ y ^ Cin,  
		assign Cout = (x & y) | (x & Cin) | (y & Cin);  
	endmodule
	
```
- Instantiates four `fulladd` modules as subcircuits

# Arithmetic Assignment Statements
Arithmetic operations are used so often that it is convenient to have them **incorporated directly into a hardware description language**  
- Verilog implements such operations using **arithmetic assignment statement and vectors**  
	- For example, an n-bit adder:
```Verilog
	input [n-1:0] X, Y;  
	output [n-1:0] S;  
	S = X + Y;
```
- Another useful mechanism is `{ }` which is used to concatenate bits together

```Verilog
	module addern ( carryin, X, Y, S, carryout );  
		parameter n = 32;  
		input carryin;  
		input [n-1:0] X, Y;  
		output [n-1:0] S;  
		output carryout;  
		assign { carryout, S } = X + Y + carryin;  // Two bit output, first bit to carryout, second to S
	endmodule

```

