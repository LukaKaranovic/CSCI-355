Slides are 02c - Introduction to Logic Circuits

# Verilog
Verilog HDL is **case sensitive**  
- module with inputs (ports) and outputs (ports)  
- statements to define the circuit  
- Structural and Behavioral Description  
- By default, everything is a wire.
**Structural Specification**  
- What the circuit looks like  
- output to nets/wires  
**Behavioral specification**  
 - What the circuit does  
- Continuous Assignments – output to nets/wires  
	- keyword `assign`
- Procedural Assignments – output to registers
	- keyword `reg`

| Specification Type                   | Pros | Cons |
| ------------------------------------ | ---- | ---- |
| Structural Specification             |      |      |
| Behavioural Continuous Specification |      |      |
| Behavioural Procedural Specification |      |      |

Gates:
- and
- nand
- or
- nor
- xor
- xnor
- not
- buf

# Structural Specification
Verilog includes a set of “gate-level primitives” of commonly-used logic gates  
- For example, a two-input AND gate, with output y and inputs x1 and x2:  
	- `and( y, x1 , x2 ) ;` 
- A four-input OR gate is specified as:  
	- `r ( y, x1 , x2 , x3 , x4 ) ;`  
- The NOT gate is given by:  
	- `not( y, x ) ;`
- The keywords nand and nor are used to define the NAND and NOR gates  
![[structuralspecex.png]]
- Specify module name
- specify the ports (inputs and outputs)
- specify the wires (intermediate outputs of gates)
	- not needed because compiler will autogenerate them for you
		- can use expressions as parameters
		- if you didn't declare `k` but used it as output, the software will make `k` for you
- for each gate, first param is output, other params are inputs

All structural specifications run at the same time (in parallel)

# Behavioural Specification
**As computer scientists, we want to use this over structural specification.**
- Using gate-level primitives can be tedious when large circuits have to be designed  
- Verilog allows the specification of the logic of a circuit:  
- So, we specify expression that defines the behavior of the circuit.

**Continuous Assignment** to a net/wire means whenever the signal on the RHS changes, the LHS will be re-evaluated.
- Called when using `assign` keyword.
- Continuous assignments are evaluated **concurrently**
![[continuousassignment.png]]

**Procedural Assignment**  
- Higher level of abstraction  
- Rather than Boolean expression, use if-else, while, for statements
- **Always block**: `always @(x1, x2)` → the block executes whenever there is a change in x1, x2 or both.  
- Statements in “always” block are evaluated in the order given (unless using non-blocking)
- Output should always use `reg` keyword for register
![[proceduralassignment.png]]

# Hierarchical Verilog Code
For larger designs, we use a “top-level” module that includes several instances of “lower-level” modules which may contain sub-modules themselves.
 - Modules can’t be instantiated inside procedural block (“always @” block)
- Lower-level modules are **instantiated** in a higher-level module (as opposed to being called from the higher-level module)

### Example - Adder + Display
![[moduledesignexample.png]]

```verilog
Half Adder Module:

	module adder(a, b, s1, s0);
		input a, b;
		output s1, s0;
		
		// Continuous behavioural assignments
		assign s1 = a & b;
		assign s0 = a ^ b;

	endmodule
```

```verilog
Display Module:
	// A module for drivign a 7-segment display.
	
	module display(s1, s0, a, b, c, d, e, f, g);
		input s1, s0;
		output a, b, c, d, e, f, g;
		
		assign a = ~s0;
		assign b = 1;
		assign c = ~s1;
		assign d = ~s0;
		assign e = ~s0;
		assign f = ~s1 & ~s0;
		assign g = s1 & ~s0;
	
	endmodule
```

```verilog
Top Level Module:

	module adder_display(x, y, a, b, c, d, e, f, g);
		input x, y;
		output a, b, c, d, e, f, g;
		wire w1, w0;
		
		// Instantiation of lower-level modules.
		adder U1(x, y, w1, w0);
		display U2(w1, w0, a, b, c, d, e, f, g);
	endmodule
```

# Tips For Writing Verilog
- The tendency for the novice is to write Verilog code that resembles a computer program  
	- Contains many variables and loops; complex and difficult to understand  
- A good general guideline is to assume that if the designer cannot readily determine what some Verilog code does, then the CAD tools are not likely to be able to synthesize the circuit  
- Paradigm shift: As opposed to computer code that runs sequentially, hardware specified in Verilog is **implemented in parallel** (think massively parallel), **all of the modules running concurrently**

# Vectored Signals
By default, each signal in Verilog is a **single bit**  
- A more convenient approach is to use multi-bit signals, called **vectors**, to represent numbers  
	- An example of an input vector is: `input [3:0] X;`  
		- This defines X to be a four-bit vector  
		- Its individual bits can be referenced by an index value in square brackets:  
		- The most-significant bit would be X[3]  
		- The least-significant bit would be X[0]  
	- A two-bit vector consisting of the middle two bits would be X[2:1]

```Verilog
	// Ripple-Carry Adder using Vectors
	
	module adder4 (carryin, X, Y, S,carryout);  
		input carryin;  
		input [3:0] X, Y;  
		output [3:0] S;  
		output carryout;  
		wire [3:1] C;  
		
		fulladd stage0 (carryin, X[0], Y[0], S[0], C[1]);  
		fulladd stage1 (C[1], X[1], Y[1], S[1], C[2]);  
		fulladd stage2 (C[2], X[2], Y[2], S[2], C[3]);  
		fulladd stage3 (C[3], X[3], Y[3], S[3], carryout);  
	endmodule
	
```

# Generic Specification
Verilog allows the use of **general parameters** to allow **flexibility** in setting the **size** of modules  
- An n-bit vector representing a number may be given by `X[n-1:0]` 

In Verilog, we define a parameter (constant):  `parameter n = 4;`  
- This would create a 4-bit vector `X[3:0]`

```Verilog
	// Generic Ripple-Carry Adder
	module addern (carryin, X, Y, S, carryout);  
		parameter n=32;  
		input carryin;  
		input [n-1:0] X, Y;  
		output reg [n-1:0] S;  
		output reg carryout;  
		reg [n:0] C;  
		integer k;  
		always @(X, Y, carryin)  
		begin  
			C[0] = carryin;  
			for (k = 0; k < n; k = k+1)  
			begin  
				S[k] = X[k] ^ Y[k] ^ C[k];  
				C[k+1] = (X[k] & Y[k]) | (X[k] & C[k]) | (Y[k] & C[k]);  
			end  
			carryout = C[n];  
		end  
	endmodule
	
```

The Verilog `generate` keyword allows **instantiation statements** to be included **inside for loops and if-else statements.**
- If a loop is included in the generate block, the **loop index** variable has to have declaration type `genvar`


```Verilog
	// Rupple-carry Adder using the Generate Capability
	module addern (carryin, X, Y, S, carryout);  
		parameter n = 32;  
		input carryin;  
		input [n-1:0] X, Y;  
		output [n-1:0] S;  
		output carryout;  
		wire [n:0] C;  
		genvar i;  
		assign C[0] = carryin;  
		assign carryout = C[n];  
		generate  
			for (i = 0; i <= n-1; i = i+1)  
			begin:addbit //for loop label  
				fulladd stage (C[i], X[i], Y[i], S[i], C[i+1]);  
			end  
		endgenerate  
	endmodule  
	
```

# Nets and Variables
A logic circuit is modeled in Verilog by a collection of interconnected logic elements and/or by procedural statements that describe its behavior  
- **Connections between logic elements** are defined using **nets** 
- **Signals produced by procedural statements** are referred to as **variables**
- A **net** represents a **node in a circuit** and is defined using **wire**  
- A **variable** can be assigned a value in one Verilog statement and retains this value until it is overwritten by a subsequent assignment statement  
	- There are two types of variables: **reg** and **integer**

In summary: 
- **nets** are connections between logic elements
- **reg** and **integer** are variables

# Representation of Numbers
We know that:
- Numbers can be given as **constants** in Verilog:
	- `<size_in_bits>'<radix_identifier><sig_digits>`
	- `3'd0` is a 3 bit decimal 0
	- Bases can be:
		- `b` - binary
		- `o` - octal
		- `d` - decimal
		- `h` - hexadecimal
		- Default (unspecified) is decimal

## Adding
Suppose
- A is an eight bit vector
- B is a four bit vector
- S = A + B will generate an eight bit sum

If B is positive, it will be padded on the left with 0 bits, so the result will be correct
If B is a negative 2's complement number, the results will be incorrect (because it will pad 0s)

To solve this, we have to **sign extend** B to the proper length:
- `S = A + {4 {B[3]}, B}` 
	- Referred to as the **replication** operator