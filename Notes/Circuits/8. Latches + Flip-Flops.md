# Sequential Logic
Up to now, we have been discussing “Combinational” Logic:  
- The **output(s)** of a circuit are a **function of** the **current state of the circuit’s inputs:**
![[Pasted image 20251027122333.png]]

“Sequential” Logic circuits are the other major types of circuits:  
- The **output(s)** of a circuit are a **function of** the **current state of the circuit’s inputs** and the **past state of the inputs:**
![[Pasted image 20251027122330.png]]
![[Pasted image 20251027122330.png]]

## Rudimentary Memory Element
A rudimentary memory element consists of a **loop that has two inverters**  
- If A = 0 and B = 1, the circuit will maintain these values  
- If A = 1 and B = 0, the circuit will maintain these values  
- The circuit has **two** possible “states”  
- **Not very useful** as no way of changing the state

# Basic Latch
Note that Qa and Qb are **complements of each other** (Ajay wtf???)

A **memory element** can be built with two NOR gates as shown below
![[basic_latch.png]]
- The two NOR gates are said to be **cross-coupled**
- This circuit is referred to a **basic latch**:
	- Input “R” **resets** the latch, “S” **sets** the latch (relative to Qa)

The **characteristic table** of a basic latch is shown below (similar to a truth table)
![[basic_latch_char_table.png]]
- Note that Qa and Qb are normally **complements** of each other  
	- The exception is when you exert “set” and “reset” at the same time

The **simultaneous release** of R and S when they were both high at the same time causes **uncertainty** in the end circuit state
- Both Qa and Qb will then go to “1”
	- But if both are “1”, then they will both go to “0” (seen in fourth row of table)

**Theoretically** the circuit could **oscillate** back and forth **forever**

In reality, some differences in the **gate delays** will have the latch **settle in one of its two stable states**, but which one?
- We cannot really predict which one which is one of the shortcoming of this type of latch

# Gated SR Latch
It may be useful to be able to **enable and disable when a latch can change**
- "Clk" acts like a **control gate**
![[gated_sr.png]]
- We still have a problem if both S and R are released at the same time.

## Gated SR Latch with NAND Gates
 What if S and R were reversed relative to Q and ~Q?  
- Using NANDs as opposed to ANDs on the “gate”  
- Leads to same characteristic table as previous Gated SR Latch:

# Gated D Latch
It is based on the gated SR latch but **replaces inputs S and R** with a **single data input D**
- Gets around problem of simultaneous S and R
![[gated_d_latch.png]]
- When Clk is 1: data D is sent to output Q
- When Clk is 0: output holds its value
- Referred to as a **level sensitive (transparent)** latch.
![[gated_d_latch_table_symbol.png]]

## Edge-Triggered D Flip-Flops
Inputs **change** in the **level-sensitive** latches (**during a clock cycle**)
- State of latch keeps updating according to its input signals
- This results in the possibility of **multiple state changes.**

To fix:
- Need for storage elements that can change their state no more than once per clock cycle
	- These are referred to as **edge-triggered** elements.
		- Master-Slave configuration

### Master-Slave D Flip-Flop
Negative edge-triggered Master-Slave D Flip-Flop:
![[Pasted image 20251029102917.png]]

Consider the timing diagram:
![[Pasted image 20251029101456.png]]
- Notice that output Q/Qs only changes on the **falling edge of Clk**
	- It changes to match D
	- This is a **negative edge-triggered** D flip-flop
	- ![[Pasted image 20251029101531.png]]
	- Value only changes if Clk goes from 1 to 0
- Qm only changes when Clk is 1, matches value of D

Positive edge-triggered Master-Slave D Flip-Flop:
![[Pasted image 20251029101314.png]]
- Can make a **positive edge-triggered** D flip-flop by reversing the "Clk"s on the gated D flip-flop
	- Place an additional inverter on the Clk input
- ![[Pasted image 20251029101549.png]]
	- Value only changes if Clk goes from 0 to 1

![[Pasted image 20251029105350.png]]
- Level-sensitive vs. Positive edge-triggered vs. Negative edge-triggered

### D Flip-Flops with Clear and Preset
For many applications, it would be useful to be able to force a D flip-flop to a known state:
- **Clear** being 1 sets Q = 0 (and ~Q = 1)
- **Preset** being 1 sets Q = 1 (and ~Q = 0)

It's most useful if the clear/preset is **asynchronous** to the clock input (happens immediately)

![[Pasted image 20251029110027.png]]
- In this case:
	- Preset being 0 sets output to Q
	- Clear being 0 sets output to ~Q

#### Synchronous Clear
**Synchronous Clear** - To **clear** a flip-flop on the **active edge** of the clock.
![[Pasted image 20251029110904.png]]

# T Flip-Flop
By including some logic to drive its inputs, a D flip-flop can appear to be a different type of storage element.
- One example is the T (toggle) flip-flop
![[Pasted image 20251029111404.png]]
- Q only flips if clock condition is met AND T is 1.

# JK Flip-Flop
Combines SR flip-flop with the T flip-flop
- Can also be used as a D flip-flop (D connected to J, and ~D connected to K)

![[Pasted image 20251029111813.png]]
