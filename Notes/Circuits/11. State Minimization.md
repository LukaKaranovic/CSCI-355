# State Minimization
When a designer has to design a more complex FSM, it is likely that the initial attempt will result in a machine that has more states than is actually required  

Minimizing the number of states is of interest **because fewer flip-flops** will be needed and the **complexity** of the combinational circuit needed in the FSM may be **reduced**  

If the number of states can be reduced, then some states are equivalent to other states:  
- Two states Si and Sj are said to be equivalent if and only if for every possible input sequence, the same output sequence will be produced regardless of whether Si and Sj is the initial state

It is possible to define a minimization procedure that searches for any states that are equivalent:  
- Very tedious to perform manually but can be automated in CAD tools  

Instead of trying to show that some states are equivalent, it is often easier to show that some states are definitely **not equivalent:**  
- This can be exploited to define a simple minimization procedure

## Partitioning Minimization Procedure
Suppose a state machine has a single input w:
- If w = 0 is applied in state Si, and the result is state Su, we call Su a **0-successor** of Si
- If w = 1 is applied in state Si, and the result is state Su, we call Su a **1-successor** of Si
- General: w = k -> **k-successor**

Equivalence:
- If two states Si and Sj are equivalent, then all of their k-successors must also be equivalent.
- We can make a minimization procedure by
	- considering the states of a machine as a set
	- break the set into **partitions** of subsets that may be equivalent
		- so if Si and Sj are in different partitions, they are definitely **not equivalent**

Step 1:
- Assume initially that all states are equivalent
	- Forms initial partition P1
Step 2:
- Form partition P2 where the set of states is partitioned into blocks where each state has the same output value
	- The idea is that states that generate different output values can't be equivalent
Continue:
- Test whether the k-successors of the states in each block are contained in one block
	- For each k, make a list of every k-successor for each state.
		- If the k-successors are in different blocks for the same k, split up the corresponding states into different partitions.
		- If the k-successors in each output list are all in the same block already for each k, the block doesn't change.
Process ends when a new partition is the same as the previous partition (no changes for one loop)

All the states within a block are equivalent, so we only need to keep one state per block.

### Example
![[initial_state_table.png]]

![[partition_step1.png]]
Now consider the successors of the states in block A B D:  
- The 0-successors are B D B, as all of these are in the same block, we assume that A B D may still be equivalent  
- The 1-successors are C F G, as all of these are also in the same block, A B D should remain in one block in the next partition
- ![[partition_step2.png]]
- F has a mismatching 1-successor (D is in a different group)

![[partition_step3.png]]

![[partition_step4.png]]

**Reduced state table:**
![[final_state_table.png]]

# Implementation
![[counter_state_table.png]]
Using K-maps, we need a flip-flop for each state variable of next state (which is based off previous state and input)
- Make a K-map for each next state variable

## D Flip-Flops
![[dflipflop_kmaps.png]]
- Using excitation table for D flip-flop, which is just D.
- ![[dflipflop_bool_alg.png]]
- Final circuit diagram: ![[dflipflop_circuit.png]]

## JK Flip-Flops
Using excitation table to make a new state table
- Remember JK flip-flop we consider the bit transitioning from y to Y for each output
	- Ex. y0 -> Y0
- ![[jkflipflop_state_table.png]]
- Have to make 6 K-maps: 1 for each Ji and Ki
- You get the circuit: ![[jkflipflop_circuit.png]]

