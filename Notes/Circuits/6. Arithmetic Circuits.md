These are slides 3a. on VIULearn.

# Number Systems
Two radices of interest when dealing with binary systems:
- base-8, referred to as “octal”
- base-16, referred to as “hexadecimal”

**Octal:**
- Not used that much nowadays
- Groups 3 binary bits into a single symbol
- Symbols 0 to 7

**Hexadecimal:**
- Very much in use nowadays
- Groups 4 binary bits into a single symbol, works well as we usually use binary number length of multiple of 8-bits
- Symbols 0-9 and A-F

## Addition of Unsigned Numbers

Four possible cases for two bits x and y:

| x   | y   | Carry Out | Sum |
| --- | --- | --------- | --- |
| 0   | 0   | 0         | 0   |
| 0   | 1   | 0         | 1   |
| 1   | 0   | 0         | 1   |
| 1   | 1   | 1         | 0   |

What about for multibit numbers?

| Carry In | x   | y   | Carry Out | Sum |
| -------- | --- | --- | --------- | --- |
| 0        | 0   | 0   | 0         | 0   |
| 0        | 0   | 1   | 0         | 1   |
| 0        | 1   | 0   | 0         | 1   |
| 0        | 1   | 1   | 1         | 0   |
| 1        | 0   | 0   | 0         | 1   |
| 1        | 0   | 1   | 1         | 0   |
| 1        | 1   | 0   | 1         | 0   |
| 1        | 1   | 1   | 1         | 1   |
- Carry Out value becomes Carry In value for next bit.
- Carry In is 0 on the first bit.

![[fulladderkmaps.png]]

![[sumtermxor.png]]

We get the following circuit:
![[circuitadder.png]]

## XOR
The XOR generates a modulo-2 sum of its inputs:
- The output is 1 if odd number of inputs are one
- The output is 0 otherwise

- The XOR does not have any minterms that can be combined:
- Can be thought of as one input as a control signal:
	- If x = 1, f = y (can use an XOR as an NOT)
	- If x = 0, f = y
- Complement of an XOR is known as a XNOR

# Decomposed Full Adder
Half-Adder adds two bits (x and y, has no carry in bit)

Full-Adder adds three bits (x, y, and carry in)

Can build a full-adder using two half-adders
![[fulladderdecomposed.png]]

# Ripple-Carry Adder
A ripple-carry adder is formed by "chaining" full-adders.
- It is called a "ripple-carry" because you have to wait for the carry to "ripple" (propagate) from the LSB to the MSB.
![[ripplecarry.png]]
- Note: If each stage has a delay of $\Delta$t, the total delay is n$\Delta$t, where n is the size in bits of the inputs.
- When 32-bit or 64-bit numbers are used, this delay can become unacceptably long.

## Design Example
Suppose we need a circuit that multiplies an eight-bit unsigned number by 3.
- Let A = a7a6a5...a1a0 
	- The number
- Let P = p9p8p7...p1p0
	- The product 3A
	- Note that we need 10 bits to represent the product.

One approach is to use two ripple-carry adders to add three copies of the number A.
- First adder: A + A = 2A
- Second adder: 2A + A = 3A
	- Note on second adder, we add a 0 infront of A so both 2A and A are the same length.

This approach doesn't work very well if we want to multiply A by 5, or 10, or 100.

A better approach is to recognize that **shifting** a binary number to the left by one bit is equivalent to multiplying by 2.
- Then we just need one adder for 2A + A to get 3A.
- Note: shifting a binary number to the right divides the number by 2.

# Signed Numbers
In decimal, the sign of a number is indicted by a "+" or "-" to the left of the most significant digit.

In binary, the sign of a number is denoted by the leftmost bit:
- 1 for negative
- 0 for positive

Negative numbers can be represented in three ways:
1. Sign-and-Magnitude
2. 1's Complement
3. 2's Complement

## Sign-and-Magnitude
- MSB represents the sign
- Remaining bits represent the magnitude of the number
	- Ex. 3 = 0011 and -3 = 1011
- This representation is easy to understand, but turns out not to be well-suited for use in computers
	- Ex. 3 + -3 = 0
	- 0011 + 1011 = 1110 (not 0)

## 1's Complement
Negative numbers are defined according to a subtraction operation involving positive numbers

An n-bit negative number, K, is obtained by subtracting its equivalent positive P, from 2<sup>n</sup> - 1:
- K = (2<sup>n</sup> - 1) - P

The 1's complement can be easily obtained by complementing (flipping) each bit of the number.
- Has some drawbacks when used in arithmetic operations.

## 2's Complement
A negative number, K, is obtained by sutracting its equivalent positive number, P, from 2<sup>n</sup>
- K = 2<sup>n</sup> - P

Works well for computers:
- Ex. 3 + -3 = 0
- 0011 + 1101 = 0000

Calculating K = 2<sup>n</sup> - P requires borrowing

Let K1 be the 1's complement of a number, and K2 be the 2's complement of a number.
- We see that K2 = K1 + 1
- A simpler way of finding a 2's complement of a number is to add 1 to its 1's complement.

Other algorithm for finding 2's complement of a number B:
- From right to left:
	- Copy all bits of B that are 0 and the first bit that is a 1
	- Flip every other bit

Sign-and-magnitude and 1's complement both have two binary numbers that represent 0, but 2's complement only has one (good).

Range of n-bit 2's complement numbers: -2<sup>n-1</sup> to -2<sup>n-1</sup> - 1

# Adder and Subtractor Unit
2's complement addition is normal.

2's complement subtraction is best if you negate the second number and add them.
- Means we need a circuit to get the two's complement of a number, and then use that as an input into an adder.

This is an adder and subtractor unit:
![[addersubtractorunit.png]]
- If 0 is passed, will add. If 1 is passed, will subtract.

# Carry-Lookahead Adders
Ripple-carry adder had a problem that the delay was a function of the number of bits (O(n))

Looking at a full-adder, the carry was given by C<sub>i+1</sub> (carry out) = x<sub>i</sub>y<sub>i</sub> + x<sub>i</sub>c<sub>i</sub> + y<sub>i</sub>c<sub>i</sub>
- Can be factored as x<sub>i</sub>y<sub>i</sub> + (x<sub>i</sub> + y<sub>i</sub>)c<sub>i</sub>
- Can be written as c<sub>i+1</sub> = g<sub>i</sub> + p<sub>i</sub>c<sub>i</sub>
	- Where g<sub>i</sub> = x<sub>i</sub>y<sub>i</sub>
	- p<sub>i</sub> = x<sub>i</sub> + y<sub>i</sub>

The function g<sub>i</sub> is equal to 1 when both inputs x<sub>i</sub> and y<sub>i</sub> are equal to 1.
- Since stage i is guaranteed to generate a carry-out if g<sub>i</sub> is 1, g is called the "generate" function.

The function p<sub>i</sub> is equal to 1 when at least one of the inputs x<sub>i</sub> and y<sub>i</sub> are equal to 1.
- If p<sub>i</sub> = 1, a carry-out is produced in c<sub>i</sub> = 1, p is called the "propagate" function.

![[carrylookaheadalgoirthm.png]]
- Each carry can be implemented as a *sum-of-products* and are all evaluated at the same time (no "ripple")

## Delays 
We found that an n-bit ripple-carry adder, the critical path has delay of 2n+1 gates.
- We found that for every 5 delays a ripple-carry adder has, a carry-lookahead adder only has 4 gate delays.

The complexity of an n-bit carry-lookahead adder increases rapidly as n becomes larger.
- To reduce the complexity, we use a "hierarchical" approach in designing larger adders.
	- Ex. Suppose we want to design a 32-bit adder:
		- Divide the adder into four 8-bit carry-lookahead adders
		- Connected the four blocks as four stages of a ripple-carry adder
- https://www.youtube.com/watch?v=dyQAW_Z-_0w

CLA - faster but requires more gates so not as cost effective