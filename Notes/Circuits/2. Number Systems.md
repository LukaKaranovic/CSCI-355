## Digital Representation of Information
- Information in logic circuits is represented as electronic signals.
- Each of these signals can be thought of as representing one 'digit' of information (as opposed to analog where a signal can represent an arbitrary number of values by its voltage)
- To make the design of logic circuits easier, each digit is allowed to take on only **two** possible values (usually denoted as 0 or 1)
- These logic values are implemented as **voltage levels** in circuits:
	- Value 0 is represented by 0 V
	- Value 1 is the voltage level of circuit's power supply (Ex. 5 V)

# Number Systems
## Decimal Numbers
In our familiar decimal system, we have 10 values and each digit represents a power of 10.
Ex. $$ 3547 = 3*10^3 + 5 * 10^2 + 4 * 10^1 + 7 * 10^0 $$
## Binary Numbers
For digital circuits, which only have two digits, we use a 'binary' number system (base-2)
- Each binary digit is called a 'bit'
Ex. $$ 1101 = 1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 $$
Left-most bit is usually referred to as the 'most significant bit' (MSB).
Right-most bit is usually referred to as the 'least significant bit' (LSB).

### Decimal to Binary
Repeatedly divide by 2 until quotient is 0, then take remainder column bottom up

| Number | Quotient | Remainder |
| ------ | -------- | --------- |
| 35     | 17       | 1         |
| 17     | 8        | 1         |
| 8      | 4        | 0         |
| 4      | 2        | 0         |
| 2      | 1        | 0         |
| 1      | 0        | 1         |
(35)<sub>10</sub> = (100011)<sub>2</sub>

With decimals: (35.125)10 = (100011.001)2
- Multiply decimal by 2, take integer part, remove it and multiply decimal by 2 until repeating pattern.
- Take integer parts from top down.

| Decimal | Result | Integer Part |
| ------- | ------ | ------------ |
| 0.125   | 0.25   | 0            |
| 0.25    | 0.5    | 0            |
| 0.5     | 1.0    | 1            |
- Since decimal part is 0, going to get repeating 0s, so we stop.

### Binary to Decimal
Start from right and multiply each digit by increasing powers of 2.
(101011)<sub>2</sub> = (43)<sub>10</sub> since
$$ 1 * 2^0 + 1 * 2^1 + 0 *2^2 + 1 * 2^3 + 0 * 2^4 + 1 * 2^5 = 1 + 2 + 8 + 32 = 43 $$

## Hexadecimal
A base-16 number system that uses the letters A-F to represent numbers 10-15.

Can convert to decimal by multiplying my powers of 16. 
Can convert to binary by turning each hexadecimal digit into 4 bits.

# Codes
**Code:** A set of n-bit strings in which different bit strings represent different numbers or other things.
**Code word:** A particular combination of n-bit values.

## Binary-Coded Decimal
- For a base-10 number system, you need ten different symbols (digits).
- Need at least four binary bits to represent ten symbols.
- A binary-coded decimal (BCD) is the most 'natural' decimal code: just a direct binary to decimal conversion of 0-9
- Packed-BCD representation places two BCD digits into one 8-bit byte
	- (12)<sub>10</sub> = (0001 0010)<sub>BCD</sub>

### ASCII
- Alphanumeric information such as letters and numbers typed on a computer keyboard, is represented as codes consistent of binary digits.
- The most common code for this type of information is ASCII
- ASCII uses **seven-bit** patterns to denote 128 (2<sup>7</sup>) different characters.
- ASCII code is used to encode information that is handled as text. For doing arithmetic operations, it is best to convert ASCII-encoded numbers into their binary representations.
- Bytes are 8 bits, so ASCII characters are saved as bytes with the MSB set to 0.

### Gray Code
- In electromechanical applications, it is sometimes necessary to represent mechanical position as a digital value.
- Consider the problem below:
	- 0 - 000
	- 1 - 001 (1 bit changed)
	- 2 - 010 (2 bits changed)
		- 001 -> 011 or 000 -> 010 (wrong value is in between and could be returned (risk of a glitch))
	- 3 - 011 (1 bit changed)

Goal of Gray Code is to get rid of the risk of glitches (incorrect values when switching numbers). 
- We devised a digital code in which only one bit changes between each pair of successive code words:

| Number | Binary | Graycode |
| ------ | ------ | -------- |
| 0      | 000    | 000      |
| 1      | 001    | 001      |
| 2      | 010    | 011      |
| 3      | 011    | 010      |
| 4      | 100    | 110      |
| 5      | 101    | 111      |
| 6      | 110    | 101      |
| 7      | 111    | 100      |

#### Algorithm
Binary to Gray Code:
1. The bits of an n-bit binary of Gray Code code word are numbered from **right to left,** from 0 to n-1.
	- Start from right end and go to the left.
2. **Bit i** of a Gray Code code word is 0 if its **i and i+1** of the corresponding binary code word are the **same**, else bit i is 1.
	- Compare with bit to the left of it, then do XOR operation.
3. When **i+1 = n**, **bit n** of the binary code word is considered to be **0**
	- Pad a 0 to the left for the last bit.

> Works like XOR gate (exclusive or). If bits are same, return 0. If bits are different, return 1.

##### Example

| Bit i | Binary Number          | Gray Code |     |
| ----- | ---------------------- | --------- | --- |
| 0     | 0                      | 1         |     |
| 1     | 1                      | 0         |     |
| 2     | 1                      | 1         |     |
| 3     | 1                      | 1         |     |
| 4     | 0                      | 1         |     |
| 5     | 1                      | 0         |     |
| 6     | 0                      | 1         |     |
| 7     | 0                      | 1         |     |
| 8     | 1                      | 1         |     |
| 9     | 0                      | 0         |     |
| 10    | 1                      | 0         |     |
| 11    | 1                      | 1         |     |
| 12    | Always assumed to be 0 |           |     |

To go from Gray Code to binary:
- Go from **left to right**
- Copy the **left-most bit**.
- Compare each bit of result to the next right bit of the Gray Code, do XOR operation on it.