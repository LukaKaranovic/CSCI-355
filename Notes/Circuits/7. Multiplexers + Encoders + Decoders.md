Slides are 4a - Bigger Combination Building Blocks on VIULearn.

# Multiplexers
- A multiplexer has two or more inputs, one or more select inputs, and one output
- The select inputs determine which input appears on the output
![[multiplexer.png]]

2-to-1 Multiplexer Circuits
![[2to1multiplexer 1.png]]

4-to-1 Multiplexer Circuit:
![[4to1multiplexer.png]]

## Larger Multiplexers
It is possible to build larger multipleers using the same approach as the 4-to-1 multiplexer.
- Usually the number of data inputs, n, is an integer power of 2.
	- This requires log<sub>2</sub>(n) select inputs
- Larger multiplexers can also be constructed from smaller multiplexers.

16-to-1 multiplexer using 4-to-1 multiplexers:
![[16to1using4to1.png]]

# Synthesis of Logic Functions using Multiplexers
- Multiplexers can be used to synthesize logic functions
	- Any circuit can be realized using multiplexers
	- Consider implementing XOR using a multiplexer:

| w1w2 | f   |
| ---- | --- |
| 00   | 0   |
| 01   | 1   |
| 10   | 1   |
| 11   | 0   |
![[synthesisxormultiplexer.png]]

The synthesized XOR can be simplified:
![[synthesis_xor_simplified.png]]

## Shannon's Expansion
Consider implementing the three-input majority function with a multiplexer, but applying logic gates to its inputs:
![[shannon_expansion_1.png]]

### Theorem
Any Boolean function, say f(w1, w2, ... , wn) can be written in the form:
- **~w1**(f(**0**, w2, ..., wn)) + **w1**(f(**1**, w2, ..., wn))
	- This expansion can be done in terms of any of the n variables, not just w1.

Ex. f = w1w2 + w1w3 + w2w3
- f = ~w1(f(0, w2, w3)) + w1(f(1, w2, w3))
- f = ~w1(0w2 + 0w3 + w2w3) + w1(1w2 + 1w3 + w2w3)
- f = ~w1(w2w3) + w1(w2 + w3 + w2w3)
- f = ~w1(w2w3) + w1(w2 + w3)

In Shannon's expansion, the term f(0, w2, ..., wn) is called the **cofactor** of f with respect to ~w1.
- In shorthand notation, may be denoted as f<sub>~w1</sub>
- Cofactor of f with respect to w1 is f<sub>w1</sub> or f(1, w2, ..., wn)

Ex. Decomposition using w2 gives:
- f = ~w2f<sub>~w2</sub> + w2f<sub>w2</sub>

You can do the expansion in terms of more than one variable:
![[expansion_multivariable.png]]
- This can be implemented using a 4-to-1 multiplexer!

#### Example
Assume that we wish to implement:
f = ~w1~w3 + w1w2 + w1w3

If we want to implement it using a 2-to-1 multiplexer, we can use Shannon's expansion on one variable.
- f = ~w1f<sub>~w1</sub> + w1f<sub>w1</sub>
- f = w1(~w3) + w1(w2 + w3)


If we want to implement it using a 4-to-1 multiplexer, we can use Shannon's expansion on two variables.
- f = ~w1~w2(~w3) + ~w1w2(~w3) + w1~w2(w3) + w1w2(1)
![[shannon_expansion_example2.png]]

# Binary Decoders
A **binary decoder** has n inputs and can **assert** one of 2<sup>n</sup> outputs depending on the state of its inputs.
- Note that only **one** output is asserted at a time
- Decoders can be designed to have either "active-high" outputs, or "active-low" outputs

![[bin_decoder.png]]
- In truth table 'x' means don't care
- It is useful to include an "enable" input (named En), which can be used to turn off all the outputs (if En = 0)


Larger decoders can be built using a sum-of-products or by using smaller decoders
![[3to8decoder.png]]
- A 3-to-8 decoder using two 2-to-4 decoders

# Binary Encoders
A **binary encoder** performs the opposite function of a decoder:
- It encodes given information into a more compact form
- Encodes information from 2<sup>n</sup> nputs into an n-bit code.
![[bin_encoder1.png]]
![[bin_encoder2.png]]
- Circuit is built using OR gates instead of AND gates

## Priority Encoders
In a **priority encoder**, each input has a priority associated with it
- Encoder outputs indicate which active inputs have the highest priority
- Truth table for a 4-to-2 priority encoder, where w3 has highest priority
![[priority_encoder.png]]

# Code Converters
The purpose of encoder and decoder circuits is to convert from one type of input encoding to a different output encoding.
- Ex. an 8-to-3 encoder encodes which input bit is active while a 3-to-8 decoder decodes which bits are active based on the input bit.

![[code_conv.png]]
- Converts a four bit binary number to a hexadecimal number on the display.

# Arithmetic Comparison Circuits
A useful type of arithmetic circuit compares the relative sizes of two binary numbers
- Called a "comparator"
	- has two n-bit inputs A and B
	- produces three outputs, AeqB, AgtB, AltB
- Desired comparator can be designed by creating a truth table, but the table will be very large
	- Better approach is to derive it by considering the **bits of A and B in pairs**

#### Example - 4-bit Comparator
- Let A = a3a2a1a0, B = b3b2b1b0
- Define four intermediate signals i3, i2, i1, i0. Each signal is true if the corresponding bits in A and B are equal
	- i<sub>k</sub> = ~(a<sub>k</sub> XOR b<sub>k</sub>)
- AeqB = i3i2i1i0
- For AgtB, consider bits of A and B from the MSB:
	- First bit position in which A and B differ determines if A is less than or greater than B:
	- if ak = 0 and bk = 1, A < B
	- if ak = 1 and bk = 0, A > B
- AgtB = a3~b3 + i3a2~b2 + i3i2a1~b1 + i3i2i1a0~b0
- AltB = ~(AeqB + AgtB) 
	- Not equal to or greater than

