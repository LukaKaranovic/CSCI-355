# Registers
A **flip-flop** stores **one bit** of information  
- When a set of n flip-flops is used to store n bits of information (such as an n-bit number), this is called a **register**
- A **common clock** is used for **all of the flip-flops in a register**

4-bit register with clear:
![[4bit_register.png]]

# Shift Registers
A shift register is made of flip-flops, where each flip-flop stores a single bit.
- The flip-flops are connected in a serial chain, so the output of one is wired to the input of the next.
- On each clock pulse, the data bit in each flip-flop moves to the next one in the chain.
- **In** is the next inputted bit, it will propagate down the chain.

4-bit shift register:
![[4bit_shift_register.png]]
- **In** propagates through all latches
![[shift_register_sample.png]]

Every **shift** represents a **multiply by two** (insert 0 at ğ¼ğ¼ğ‘›ğ‘›)  
- Useful as a delay

## Parallel-Access Shift Register
In computer systems, it is often necessary to **transfer n-bit data words**  
- This can be done by transmitting all of the bits at the same time using **n separate wires** (referred to as â€œparallelâ€)  
- The bits could be transmitted **one bit at a time** on one wire using n consecutive clock cycles (referred to as â€œserialâ€)  
- To transfer an n-bit data word **serially**, we can use a shift register that can be **loaded** with all n bits in parallel
![[parallel_shift_register.png]]

# Counters
Counters are **circuits** that can **increment or decrement a count by 1**  
- Counters can be implemented by **adder/subtractor circuits**  
- But since they only **change by 1** at a time, can be implemented much more simply using T and D flip-flops

## Asynchronous Counters
The simplest counter can be built using T flip-flops because the toggle feature is naturally suited for counting

A 3-bit up counter:
![[3bit_up_counter.png]]
- All stages set to toggle  
- Clock only goes to the first stage  
- The clock for the other stages is the positive edge of ~Q of the previous stage

A 3-bit down counter:
![[3bit_down_counter.png]]

## Synchronous Counters
The **asynchronous counters** previously shown are simple but **not very â€œfastâ€** (limited maximum clock speed)  
- The delays caused by the cascading clock scheme may become too long for a large number of bits 

We can build a faster counter by **clocking all flip-flops at the same time**

### Synchronous Up Counter
The contents of a three-bit up counter for eight clock cycles, assuming the initial count is 0:
![[sync_3bit_counter.png]]

The circuit:
![[sync_3bit_counter_circuit.png]]
- All outputs change at the same time, so referred to as a â€œsynchronousâ€ counter
- Maximum speed limited by cumulative delay of the AND gates and flip-flop

### BCD Counter
Binary-Coded-Decimal (BCD) counters are module-10 counters  
- Example shown is a two-digit BCD counter (counts 0-99)  
- First stage clears on 9  
- Second stage only enabled to count on a 9  
- Second stage clears on 99  
- Additional Clear signal added  

![[bcd_counter.png]]

## Ring Counter
We can devise a counter in which each flip-flop reaches the state Qi = 1 for exactly one count, while 0 for all other counts  
- The output of this counter does not represent a binary number, it represents a code  
- Also called shift register counter

How it works:
- The output of the last stage is fed back to the first stage  
- The counter must be initialized with a single 1  
- A four-bit ring counter would have outputs 0001, 0010, and 0100, and 1000 (from MSB to LSB)  
- Number of states is equal to the number of flipflops used
![[ring_counter.png]]

## Johnson Counter
Johnson counters work like Ring counters, except the input for the first flip-flop is the complement of the last one
- Initial input is 0

You get the sequence: 0000, 1000, 1100, 1110, 1111, 0111, 0011, 0001, 0000