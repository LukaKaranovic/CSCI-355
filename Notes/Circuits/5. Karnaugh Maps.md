Slides on VIULearn are 02d - Introduction to Logic Circuits

## Logic Minimization
In general, it is not obvious which Boolean theorems and properties to use to  
simplify Boolean expressions  
- The “combining” property is one property that we can use to systematically simplify expressions:  
	- 14a: xy + x~y = xy
	- 14b: (x + y) (x + ~ y) = x
- One interpretation is that if two expressions have all the same terms and only differ by the complement of a single term, the two expressions can be “reduced” to a single expression with the complemented term removed.

# Karnaugh Maps
K-Maps are a geometric representation of a logic expression that facilitates logic minimization  
- An **alternative** to the **truth table** form for representing a function  
- It allows for easy **discovery of groups of minterms than can be combined** (i.e., apply the combining property)  
- A two-variable function can be represented by
![[kmapexample.png]]

## Three-Variable K-Map
![[threevarkmap.png]]
- Important that adjacent cells differ by only one bit (like Gray Code)

Can construct a four-variable k-map the same way.

For five-variable k-maps, we want to construct **two four-variable k-maps**.
- one with 5th variable being 0 
- one with 5th variable being 1

**Note:** right and left ends of k-maps are connected (like a cylinder). The top and bottom ends of k-maps are also connected

## Strategy for Minimization
We can use an intuitive approach on how to groups 1s to find the minimum-cost implementation for a circuit:
- For larger logic functions, which have many variables, an intuitive approach is unsuitable
- Instead, an organized method for deriving a minmium-cost implementation is required:
#### Terminology
>**Literal**:  
	• A product term consists of one or more variables, each variable, in either  
	uncomplemented or complemented form, is called as “literal”  
	• e.g. product term x1 ~x2 x3 has three literals  
   **Implicant**:  
	• A product term for which a given function is equal to 1  
	• Any (power of 2) grouping of adjacent 1s (in rectangular shape)  
   **Prime Implicant (PI)**:  
	• an implicant that can not be ”grown” any bigger  
	• Represent “the largest groups of 1s” that can be circled in a Karnaugh map
   **Cover**:  
	• A set of implicants that include all the 1s  
	• A number of different covers exist for most functions  
   **Distinguished 1-Cell**:  
	• An input combination (i.e., a cell in the K map) that is only covered by one PI  
   **Essential Prime Implicant**: 
	• A PI that must be included in a cover  
	• Has one or more distinguished 1-cells  
   **Secondary Prime Implicant (Non-Essential PI)**:
	• an implicant that is not an essential PI


### K-Map SoP Min Algorithm
1. Identify all prime implicants
2. Identify the set of essential prime implicants E
3. Select the minimum set of non-essential (secondary) prime implicants N such that {E} U {N} forms a cover.
#### Examples
![[minsopex1.png]]
![[minsopex2.png]]
![[minsopex3.png]]
![[minsopex4.png]]

### K-Map PoS Min Algorithm
Same algorithm, but look for 0s instead of 1s.
1. Identify all prime implicants
2. Identify the set of essential prime implicants E
3. Select the minimum set of non-essential prime implicants N such that {E} U {N} forms a cover.
4. When converting, make sure to remember its in maxterms. 
	- Ex. This means complement x1 if there is a 1 present in its bit.
#### Examples
![[minposex1.png]]![[minposex2.png]]
## SoP vs. PoS Implementation
In general, the **SoP and PoS** implementations of a given function **may or may not** have the same cost  
- To find the minimum cost implementation, should look at **both** implementations  

An alternate approach to find the minimum-cost PoS:  
- Finding the minimum-cost SoP of the complement of a function f
- Then can apply DeMorgan’s theorem to this to obtain the minimum-cost PoS implementation using f = ~(~f)  
- Should provide the same solution as “direct PoS approach", but some people may prefer working with SoP from Karnaugh maps  

#### Example
![[indirectminposex1.png]]

*Observation: In a map of size 2\^x, a group of size 2\^n is a product of x - n terms*

## Incompletely Specified Functions
- In digital systems, it often happens that **certain input conditions can never occur**  
- For example, consider two interlocking switches (x1 and x2) that can never be closed at the same time  
- Then we say that (x1, x2) = 11 is a “don’t care” condition  
- Functions with "don’t care" conditions are said to be **incompletely specified** 
- "Don’t care" conditions can be used to determine lower cost implementations of logic circuits:
	- We use the notation $\sum$ D (...) to indicate the minterms which are under "don’t care"  
	- Selectively, we can choose to use "don’t care"s in prime implicants
	- Mark "don’t care"s in K-maps with "d"